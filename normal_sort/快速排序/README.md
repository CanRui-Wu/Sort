#快速排序
     快速排序是目前被认为在一般情况下最快的排序算法，也是C++STL的排序使用的算法。快排首先选择一个元素，并把比该元素大的放到右边(无序)，小的放到左边(无序)，然后划分成两边，对两边重复上述过程。<br />

元素的选择
==========
快排每次用来划分的元素的选择可以是固定某一位（如第一位或最后一位），但是这样在遇到有序数组或者逆序数组等特殊的数组的时候执行时间会特别慢。<br />
为了让执行时间尽量平均，最好的选择是采用随机元素，这样执行时间的方差会比较小，但是均值不会变化。<br />

划分的方式
==========
选择一个元素，与最后一个元素交换。然后设定两个索引，一个指向最左边，另一个指向最右边。<br />
两个索引可以移动，但是当两个相同时，马上结束。<br />
左边索引不断向右移动，直到碰到第一个比当前最后的元素大的元素。然后，右边的索引移动，直到碰到第一个比当前最后元素小的元素。然后交换它们，不断重复上述过程，直到两个索引相同。<br />
交换两个索引相同指向的元素与最后那个元素，索引左边就是比索引指向元素小或相等的那些元素，右边则是大或相等。<br />
对左边那块和右边那块重复上述过程进行递归划分，最终数组将会有序。<br />


时间复杂度
==========
最好情况下，每次划分两边的大小都一样，递归深度logn，每层划分需要O(n)，总时间复杂度O(nlogn)。<br />
最差情况下，每次划分都有一边没有元素，递归深度n，每层划分平均需要(n-1+n-2+...+0)/n=O(n)，总时间复杂度O(n^2)。<br />
平均情况下，我们直接计算总的交换次数，假设C(n)代表长度为n的快速排序平均比较次数。<br />
那么C(n)=(n+1)+(C(0)+C(n-1))/n+...+(C(n-1)+C(0))/n。将n换成n-1，相减可得 C(n)/(n+1) = C(n-1)/n + 2/(n+1)。<br />
求解递推方程可得C(n)≈2nln(n)，因此平均时间复杂度是O(nlogn)的。<br />

![链接已失效](https://github.com/CanRui-Wu/Sort/blob/master/normal_sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/quick_sort.gif)







