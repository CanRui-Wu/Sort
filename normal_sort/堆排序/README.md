#堆排序
堆排序是建立在堆这种数据结构基础上的选择排序，是原址排序，时间复杂度O(nlogn)，堆排序并不是一种稳定的排序方式。堆排序中通常使用的堆为最大堆。<br />

堆的定义
========
堆是一种数据结构，是一颗特殊的完全二叉树，通常分为最大堆和最小堆。<br />
最大堆的定义为根结点最大，且根结点左右子树都是最大堆；同样，最小堆的定义为根结点最小，且根结点左右子树均为最小堆。<br />
最大堆满足其每一个父结点均大于其左右子结点，最小堆则满足其每一个父结点均小于其左右子结点。<br />

堆的存放
========
在堆排序中，堆所表示的二叉树并不需要额外使用指针的方式在计算机中存放，因为堆是完全二叉树，因此只需要使用原来的数组表示即可，将树的结点，从上至下，从左至右一个个放到数组中去。<br /> 
因此，如果数组的起始索引为0，对于一个结点i来说，它的父结点索引为[(i-1)/2]，它的左子结点索引为2i+1，右子结点索引为2i+2。<br />
最后一个非叶子节点就是最后一个结点的父亲，如果数组长度为n，那么其索引为[(n-2)/2]。<br />


堆排序主要步骤
==============
1. 将无序序列构建成最大堆。<br />
2. 将数组分成两个区域，有序区和无序区，初始时创建一个整数i为数组的长度，用来划分有序区和无序区，有序区初始为空。<br />
3. 将堆顶元素和最后一个无序区的元素交换，然后i-1。<br />
4. 调整使得所有无序区的元素重新为最大堆。<br />
5. 重复3，4步，直到 i = 0。<br />

堆的调整
========
　　假设有某棵完全二叉树，其左右子树均为最大堆，如何调整使得该二叉树成为最大堆呢？如果根结点大于左右子结点，那么已经是最大堆了，无需调整。否则，交换根结点和左右子结点中较大的那个。假设交换的是左结点，那么目前这棵完全二叉树右子树仍然是一个最大堆，左子树则不一定，但是左子树的左右子树还是最大堆，因此不断递归下去调整即可。<br /> 
    因此，交换最后一个元素和堆顶元素后的调整步骤，就和上面所说的一致。而将无序序列构建成最大堆，同样也可以运用这一点。从最后一个非叶子结点到第一个非叶子结点（根结点），对这些结点作为根结点的子树，按顺序调用一次上述描述的调整即可（每次调用时，该子树的左右子树必定是最大堆）。<br />

堆排序性质
==========
1. 时间复杂度O(nlogn) 
　　 每次调整，是沿着树的某一分支一直往下的，按最坏的情况计算，是O(logn)的复杂度。 初始化需要⌊(n-1)/2⌋次调整，后面则需要n-1次调整，每次调整即有一个输出，因此最坏情况下是O(nlogn)的复杂度。<br />
2. 空间复杂度O(1) 
   空间复杂度可以明显地从算法中看出，不管待排序列多大，只需要常数个额外的空间即可，因此是原地排序。<br />
3. 不稳定排序
   堆排序显然不是稳定排序，这点举个反例即可简单认证。假设某个初始序列就是最大堆了,对于[3,2,1,2]，第一层子节点的2反而会先与堆顶交换，从而排到后面去。<br />

![链接已失效](https://github.com/CanRui-Wu/Sort/blob/master/normal_sort/%E5%A0%86%E6%8E%92%E5%BA%8F/heap_sort.gif)


