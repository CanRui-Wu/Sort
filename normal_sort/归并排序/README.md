归并排序
=======
归并排序是建立在归并操作的一种排序方式。其运用了分治法的思想，只要递归地进行归并操作即可得到有序的序列。<br />
其最大的优点在于排序方式为外部排序，对于数据量极大的序列内存一次性装不下，可采用这种方式排序。<br />

归并的路数
==========
归并排序可以指明一个大于2的整数k，称为k路归并排序。<br />
“归”，指的是将原序列分成k个子序列，然后使每个子序列有序；“并”，指的是将k个有序的子序列合成一个有序的序列。<br />
为了使每个子序列有序，让每个子序列再分成k个子序列使之有序后再合并成一个有序的序列。<br />

归并排序主要步骤
===============
1. k路归并排序，就将序列等分成k个子序列。<br />
2. 对每个长度大于1的子序列重复1-3的过程。<br />
3. 借助一个额外的辅助数组，将k个有序的子序列合并成一个有序的序列。在合并k个有序的数组时，如果k大于2，可以利用堆使合并从O(nk)变成O(nlogk)。<br />


相关性质
========
1. 归并排序时间复杂度非常稳定。因为无论是什么样的数组，操作都是一样的。<br />
递归深度O(logk(n))，底数和k相关，对于2路归并排序则为O(logn)，2路合并总共需要O(2n)的复杂度,k路合并需要O(logkn)的复杂度。<br />
因此，对于2路归并排序，平均时间复杂度为O(nlogn)，对k路，则为O(logk*n*logk(n))，其中k为常数。<br />
2. 空间复杂度，整个归并排序可以共用一个辅助数组，长度为初次调用归并排序时的长度n，因此空间复杂度为O(n)。<br />

![链接已失效](https://github.com/CanRui-Wu/Sort/blob/master/normal_sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/merge_sort.gif)
